# 1. 用到本地缓存来缓存配置信息。
    选用Caffeine来实现本地缓存，通过CacheManager来与SpringBoot进行整合。CaffeineCacheManager是Caffeine的包装类，进行代理包装。
    SpringBoot的CacheManager和Cache，也就是SpringBoot Cache是如何实现的？
    通过ConditionalOnProperty注解来实现是否开启此本地缓存。
    通过DubboService注解的Group来实现广播通知，刷新本地缓存。
    通过@Cacheable注解来进行缓存管理。 
        还有@CachePut、@CacheEvict、@Caching、@CacheConfig、@EnableCaching(开启缓存模块注解)
# 2. 后台多环境陪配置同步
    配置是用GitLab进行保存管理的。鲁班可以通过表格生成JSON文件。通过GitLab的api进行读取配置，写入MongoDb，来实现多环境配置同步。
# 3. 支付流程
    客户端向服务端请求创建订单(限购拦截也是这里做的)，返回客户端订单号。客户端与SDK交互进行购买支付。支付成功后，SDK通过HTTP进行回调服务端。服务端根据订单号进行发货(进行验签(MD5加密)和根据订单状态进行幂等校验)。因为进行支付会跳转到三方页面，可能存在断线。所以在断线重连后，前端会请求后端查询订单，返回订单的信息，前端进行展示。
    订单状态有未支付、未发货、已发货、已取消、已退款 五种状态。
	退款流程: 退款SDK会通过HTTP进行回调。此时只做了GA统计。目前没有发现有退款的。因为和产品商量后，有大量退款时再进行进一步处理。因为退款涉及到退货，但是用户已经把货币花没了，如何处理等。
# 4. 登录流程
    登录: 平台有个用户id，项目内也有一个id进行对应。为什么有个对应，第一属于解藕，这个id用户是可以看到的，第二后续有规划卖靓号的诉求。 有两个HTTP接口，也是唯一暴漏的HTTP接口，一个是预检查，检查版本强更和热更。一个是登录接口，返回建立长链接的地址，客户端会进行建立长链接。
    用Netty做的长链接，也是WebSocket。这里的区别是啥？
# 5. 服务状态
    用户服务、链接服务(网关)、匹配服务、房间服务、商城服务。其中链接服务、匹配服务、房间服务是有状态的，因为本地会存储临时数据。
# 6. MongoDB为什么快
# 7. 性能优化
    JVM优化
    MongoDB读写分离
    需要显示用户的地区，因为是日本访问香港，耗时达到600ms左右，通过解析后用Redis进行缓存来解决，下一次就不用访问香港了。
    Disruptor优化，通过实现Disruptor自带的接口转化器来进行消息转化，减少对象的创建。因为Lambda每次都会生成一个对象，传入的外部变量都是这个对象的属性。
# 8. GA统计
    按照预定的格式打日志。运维通过解析日志，往GA系统进行录入。
# 9. 匹配服务
    通过本地MatchSlot进行匹配，通过延时队列进行加机器人。
# 10. 房间服务
    通过Disruptor进行无锁化。
    通过状态机进行流转，进行解藕合。延时队列DelayQueue进行延时处理。因为每个房间最多4个延时对象，所以根据房间能算出对象个数，最多8千个。
    优化内存: 通过统一的对象申请，牌的包装，Stream流的相类似的简化版本，来减少对象创建，减少垃圾回收次数，来减少STW的时间。
    大概2-3天1次yungGC。因为大部分都是房间对象，会进行复用。Disruptor的消息转化之前用的是Lambda表达式，后来用自带的Disruptor接口来实现转化，减少对象的创建。
    打日志的debug需要判断是否开启。
    役计算、结算流程，都是用责任链设计模式开发。
    牌谱用AOP切面，切发消息事件进行记录，后续客户端根据消息进行还原。牌谱行为数据存储在CDN上，基本信息存储在MongoDB上。
# 11. 用Disruptor本地消息队列进行无锁化
# 12. 商城服务
    背包模块: 通过前后端增量和全量消息来减少访问频次。用分布式锁保证数据正确性。没有用缓存。
    道具和商品模块: 所有权益、角色、皮肤、商品进行道具化。商品也是用全量和增量消息来减少访问频次。
    活动框架模块: 通过事件触发，根据process原数据进行匹配，通过反射进行调用。通过属性原数据进行支持多存储引擎。配合后台可以方便测试人员测试。
# 13. 痛点解决
    
